1.why string is immutable?
https://stackoverflow.com/questions/22397861/why-is-string-immutable-in-java
2.real time scanrio for string ? string s="raja" (string pool) string s1 = new String("raja"); -- both objects are same or different?
3.in whcih scenario which collection can be used?
4.comparable vs comparator? which one is better? can we acheive custom sorting using comparable?
like
Employee e1 = new Employee();
e1.setName("sfds");
e1.setAge(3);

Employee e2 = new Employee();
e2.setName("ss");
e1.setAge(5);

Employee e3 = new Employee();
e3.setName("tttt");
e3.setAge(6);

Employee e4 = new Employee();
e1.setName("sfds");
e1.setAge(1);

want to sort based on age in desc order..can we achieve using both ways?

5.HashMap h= new HashMap();

Employee e1 = new Employee();
e1.setid("x");
e1.setAge(3);

Employee e2 = new Employee();
e2.setid("x");
e1.setAge(5);

Employee e3 = new Employee();
e3.setid("x");
e3.setAge(6);

Employee e4 = new Employee();
e1.setid("x");
e1.setAge(1);

h.put(e1,e1);
h.put(e2,e2);
h.put(e3,e3);
h.put(e4,e4);

and if we add for set? what is the output? e1,e2,e3 objects ..with same id and name.? will it remove duplicate?

what is the output?


6.hashmap vs hashset?
7.treeset vs sortedset?
8.LinkedList vs ArrayList?
9.HashMap internal architecture?

10.how to make collection as sysnchronized?
where and for which we can use synchronized keyword(methods,blocks) what is the use ? which one is better?

11.how to make a class immutable? including variables and methods?
if suppose we have setters and getters for that class how we can restrict to use them?

12.what is application context?
13.how to get application context?

if we write logic to get appcontext 2 times and getting some singleton bean 2 times using 2 diff application context..bith beans will print same 
hashcode?

14.controller vs rest controller
15.how to start spring boot application without using springbootapplication annotation?
what are the annotations being used inside springbootapplication?

16.in what layer which annotation will b used?

17.component annotation vs repository annotation?
18.5th Highest salary
19.serialization -constructor will b called - deserialization - constructor will not b called
	implements externalizable - will not b called - desria - will b called.
20.Hibernate n+1 select problem
 
https://www.elastic.co/guide/en/elasticsearch/reference/6.2/docs-bulk.html
https://www.elastic.co/guide/en/elasticsearch/reference/5.4/indices-templates.html
https://qbox.io/blog/elasticsearch-exploring-parent-child-relationships

elastic reindexing if we have changed mapping..
elastic bulk insert
what are filters in elastic and queries?



----------------------------------------------------------------------------------------------------


--------RAML TO SWAGGER---------
oas-raml-converter --from RAML --to OAS20 C:\Rajasekhar\PROJECTS\callback-test\filedownload.raml > C:\Rajasekhar\advicedownload-swagger.json
--------RAML TO SWAGGER---------

http://www.mastertheboss.com/jboss-frameworks/resteasy/using-rest-services-to-manage-download-and-upload-of-files - DOWNLOAD/UPLOAD REST API
#############################################################################################################
http://www.javarticles.com/2017/03/mule-message-exchange-pattern-example.html - mule message exchage pattern
 
 <apikit:config name="test-config" raml="test/test.raml" consoleEnabled="${console.enabled}" consolePath="console" doc:name="Router" />

 <flow name="post:/testflow:test-config" processingStrategy="synchronous">
	<vm:inbound-endpoint connector-ref="test-vm-connector" path="test.vm.connector.path" exchange-pattern="one-way" />
	<!--some processing http request logic -->
</flow>
 <vm:connector name="test-vm-connector" createMultipleTransactedReceivers="true">
     <vm:queue-profile maxOutstandingMessages="10000">
        <default-in-memory-queue-store/> 
     </vm:queue-profile>
    </vm:connector>
#############################################################################################################	
	

################### Kafka consumer load testing for 500 requests ###################
package com.raja;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.Properties;

import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.Producer;
import org.apache.kafka.clients.producer.ProducerRecord;


public class KafkaProducerTest {

    public static void main(String args[]) throws IOException, InterruptedException{
    	
    	FileReader fr = new FileReader(new File("C:\\Users\\Downloads\\mv-kafka-client-samples-master\\src\\main\\java\\test.txt"));
    	StringBuffer message = new StringBuffer();
    	
    	BufferedReader br = null;

		br = new BufferedReader(fr);

		String sCurrentLine;

        Properties props = new Properties();
        props.put("bootstrap.servers", "0.20.1.1:8080"); 
        props.put("acks", "all");
        props.put("retries", 0);
        props.put("batch.size", 16384);
        props.put("linger.ms", 1);
        props.put("buffer.memory", 33554432);
        props.put("max.request.size", 6291456);
        
        props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
        props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");

        Producer<String, String> producer = new KafkaProducer<>(props);

        while ((sCurrentLine = br.readLine()) != null) {
			message.append(sCurrentLine.replace("\n", ""));
        }
			
		//Manipulate this string and replace the deal id from sequence generator	
        System.out.println("message -> " + message);
        
        for(int i=1;i<500;i++){
        	String topicMsg = "";
        	
        	topicMsg = message.toString().replace("551-00001","551-0000"+(i+1));
        	
        	Integer partition = (int)(Math.random()*5);
        	System.out.println("topicMsg:"+topicMsg);
        	producer.send(new ProducerRecord<String, String>("kaf_sit_test",partition,  String.valueOf(partition), topicMsg));
        }
       // Integer partition = (int)(Math.random()*5);
    	//producer.send(new ProducerRecord<String, String>("kaf_sit_test",partition,  String.valueOf(partition), topicMsg));

        producer.close();
      }
}

--using spring boot
@EnableEncryptableProperties - enable it for boot main class
add this dependency - <dependency>
	       <groupId>com.github.ulisesbocchio</groupId>
	       <artifactId>jasypt-spring-boot-starter</artifactId>
	       <version>2.0.0</version>
	    </dependency>
	    
	 add encrypted password in yml file ..then boot automatically will converted that as decrypted password if u r using it for
	 connectiong jms connector.
	 jms.password = ENC(sfsdfSdasdad#asda) - encrypted password
	 <jms:connector name="jmsConnector" doc:name="JMS Webmethods Config"
		connectionFactoryJndiName="${jms.connection.factory}" 
		username="${jndi.username}" password="${jms.jndi.password}" 
		jndiDestinations="true" jndiInitialFactory="${jms.context.factory}"
		jndiProviderUrl="${jms.jndi.url}" validateConnections="true"
		specification="1.1" />
	    
	    
https://qbox.io/tutorials ---------------------------------------------------elastic search

>> stackoverflow error/Outofmemory error
>> RestTemplateAdvice/RestControllerAdvice
>> CheckedException/UncheckedException - custom exception is checked or unchecked exception?
>> Hibernate - One to Many(1000 records) fetch="eager" is theere any performance issue?
>> In Functional interface if we have same method with overloaded signature as just like abstract? what will happen?
>> stream vs parallel stream ..should i use always parallel stream for better performance?
>> HashMap insertion order(inserted keys 1 to 100) can we get insertion order by keys ?
>> Comparator can we apply for Maps?
>> TreeMap sorting order?
>> Executors if i give 1000 thread pool size for collection of 1000 objects will we get good performance? No
>> Springboot advantages?
>> Hibernate n+1 problem?
>> Sonarcube?
>> JaCoco maven plugin?
>> JUnit integration testing?
>> Mongodb when to use?
>> How to preserve insertion order in HashMap?
>> propagation levels- REQUIRED,REQUIRES-NEW when to use them?
>> Spring AOP - pointcut,advice,joinpoint
>> what is the difference between servlet and spring mvc servlet.
>> http request and ajax request
>> servlet is threadsafe?
>> what is the benefit of making immutable?
>> how to make immutable an object as immutable?
>> How to preserve insertion order in HashMap?
>> what is deadlock and how and when it will happen?
>> Hibernate lazyness issues
>> Transaction Management in spring
>> hibernate vs jpa..which one is better?

>> with out using component scan in springboot how do u inject dependency class into dependent class?
	using spring.factories - src/main/resources/META-INF/spring.factories
	ex: org.springframework.boot.env.EnvironmentPostProcessor = com.example.hello.env.LocalSettingsEnvironmentPostProcessor
	https://github.com/snicoll-demos/hello-service-auto-configuration
	https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-auto-configuration.html
>> if suppose we have 2 data sources for u r application .. how do u ensure u r connecting to correct datasource in spring application.
	using Qualifier annotation
>> in hibernate how will u avoid partial commits - what is the annotation
#################################### JUNIT MOCKITO

@Mock creates a mock. @InjectMocks creates an instance of the class and injects the mocks that are created with the @Mock (or @Spy) annotations into this instance. 
Note that you must use @RunWith(MockitoJUnitRunner.class) or Mockito.initMocks(this) to initialise these mocks and inject them.

@RunWith(MockitoJUnitRunner.class)
public class SomeManagerTest {

    @InjectMocks
    private SomeManager someManager;

    @Mock
    private SomeDependency someDependency; // this will be injected into someManager

     //tests...

}

############################### SQL QUERY TO FORMAT DATE AS ISO FORMAT:
select TO_CHAR(SYSTIMESTAMP,'YYYY-MM-DD"T"HH24:MI:SS.FFTZR') from dual;
DateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.sZ");
String s = sdf.format(new Date());
String date = ZonedDateTime.now(ZoneId.systemDefault()).withNano(0).format(DateTimeFormatter.ISO_OFFSET_DATE_TIME);

################################ MONGODB:
var now = new Date();
print(now.getTimezoneOffset());
db.mycollection.save( { date: now,
                offset: now.getTimezoneOffset() } );

db.getCollection('mycollection').find({});
var record = db.mycollection.findOne();
print(record); 
var localNow = new Date( record.date.getTime() -  ( record.offset * 60000 ) );
print(localNow); 

TO SEE QUERY EXECUTION STATISTICS:
db.getCollection('collection-name').find({}).explain("executionStats");
--create index in mongodb for columns
db.COLLECTION-NAME.createIndex({ student: 1, type: 1 });
--create index programatically using spring data mongodb

############################ save mongo collection date with iso format - mongodb by default stores date in UTC time stamp.
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createDate;
    
    //CREATE INDEX FOR MONGO COLLECTION
    @Document
    @CompoundIndex(def = "{'firstName':1, 'salary':1}", name = "person_index")
    public class Person {
    @Id private String id;
    
########################## NPM INSTALL
npm set repository http://registry.npmjs.org/
npm set proxy http://00:00:00:00:8080/ 
1.npm install
2.npm run build
3.npm start 

########################## spring data mongodb lookup operation - join with other collection
    Employee e =new Employee();
		e.set_id("1");
		e.setDept_id("100");
		e.setName("Raja");
		
		Department d = new Department();
		d.set_id("100");
		d.setDept_name("XYZ");
		
		
		this.mongoTemplate.insert(e, "employee");
		this.mongoTemplate.insert(d, "department");
		
		LookupOperation lookupOperation = LookupOperation.newLookup()
                .from("department")
                .localField("dept_id")
                .foreignField("_id")
                .as("departments");
	    Aggregation aggregation = Aggregation.newAggregation(
	    		match(new Criteria("_id").is("1")) , lookupOperation);
	    List<EmpDeptResult> results = mongoTemplate.aggregate(aggregation, Employee.class, EmpDeptResult.class).getMappedResults();
	    System.out.println(results);
	    this.mongoTemplate.dropCollection("employee");
	    this.mongoTemplate.dropCollection("department");
	    
	    >> https://stackoverflow.com/questions/44471800/spring-data-match-and-filter-nested-array
	    >> https://stackoverflow.com/questions/43470578/spring-data-mongo-db-query-embedded-array
	    >> https://stackoverflow.com/questions/44949720/spring-mongotemplate-mapping-aggregation-result-to-collections-e-g-list-and
	    >> https://github.com/spring-projects/spring-data-mongodb/blob/master/src/main/asciidoc/reference/mongo-repositories.adoc
		
		List<AggregationOperation> list = new ArrayList<AggregationOperation>();
		list.add(Aggregation.unwind("documentRequest"));
		list.add(Aggregation.unwind("documentRequest.documentDetails"));
		list.add(Aggregation.match(Criteria.where("documentRequest.documentDetails.docId").is("DOC1")));
		list.add(Aggregation.match(Criteria.where("documentRequest.documentDetails.customerId").is("11111111")));
		list.add(Aggregation.project().andExclude("_id"));
					ObjectMapper mapper = new ObjectMapper();
					mapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);

		TypedAggregation<DocumentRequestObj> agg = Aggregation.newAggregation(DocumentRequestObj.class, list);
		List<Document> dbObjects = mongoTemplate.aggregate(agg, "document_grouping", Document.class).getMappedResults();     
		System.out.println(dbObjects.get(0).toJson());
		//mongoTemplate.getConverter().read(DocumentRequestObj.class, dbObjects.get(0));

//Pagination Mongodb Query Criteria
	Criteria criteriaType = new Criteria();
		Query query = new Query(criteriaType);
		PageRequest pageableRequest = new PageRequest(pagenumber - 0, pagesize -10, new Sort(new Sort.Order(Sort.Direction.DESC, "iso_timestamp")));
		query.with(pageableRequest); 

######################### Hibernate fetch strategy
@Entity
@Table
public class Parent {
    @Id
    private Long id;

    @OneToMany(mappedBy="parent", fetch = FetchType.EAGER)
    @Fetch(FetchMode.JOIN)
    private List<Child> child;    
    //getter setters
}

@Entity
@Table
public class Child {    
    @Id
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    private Parent parent;

    //getter setter
}
In above example, when getting Parent entity, hibernate will automatically load all child entities eagerly using join. On the other hand, 
when you fetch Child, Parent entity won't be selected unless you call it explicity in your code child.getParent().
FetchType (Lazy/Eager) tells whether we want entity to be loaded eagerly or lazy, when there's call in code.
FetchMode (Select/Join) tells whether we want our entitity to be loaded with additional select or in one query with join or subselect.
>>FetchMode : It defines how hibernate (using which strategy, e.g. Join, SubQuery etc) will fetch data from database.
>>FetchType : It defines whether hibernate will fetch the data or not.
NOTE : FetchMode is only applicable when FetchType = EAGER while annotation.

>>https://docs.mulesoft.com/mule-user-guide/v/3.6/splitter-flow-control-reference#full-example-code-3
>>https://docs.mulesoft.com/mule-user-guide/v/3.6/scatter-gather
-------------Oracle 12c---------------------
alter session set container=orclpdb;
create user raja identified by raja;
grant create session to raja;
connect raja/raja@orclpdb;--pluggable database.	

//ELASTIC SEARCH
to see content of elastic index:
curl -H 'Content-Type: application/json' -X GET https://localhost:9200/index_name/_search?pretty
>> PRIME NG module for graphs,charts,grids - Angular 
>> Lombak - maven plugin - annotate @lombak for your pojo then it will create setter and getters internally.
<!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.0</version>
    <scope>provided</scope>
</dependency>
@Entity
@Getter @Setter @NoArgsConstructor // <--- THIS is it
public class User implements Serializable {
 
    private @Id Long id; // will be set when persisting
 
    private String firstName;
    private String lastName;
    private int age;
  
 ///////////////////////////// Elastic ////////////////////////////////////
    PUT localhost:9200/books?&pretty - CREATE INDEX books
curl -XPUT 'localhost:9200/books?&pretty'

GET localhost:9200/books/_mapping?&pretty - mappings for index
CURL -XGET 'localhost:9200/books/_mapping?&pretty'
 
curl -XPOST 'localhost:9200/books/fiction/1?&pretty' -d @books.json -H 'Content-Type: application/json'
localhost:9200/books/fiction/1?&pretty

books.json:
{
"name":"Java",
"author":"Rajasekhar",
"cost":"200.50",
"Available":"true",
"publishers":"Graham Hills",
"date":"2018-05-07"
}

####################### Example for create daily elastic search index ###################

https://www.elastic.co/guide/en/x-pack/current/securing-aliases.html

import com.google.common.io.ByteStreams;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.scb.batch.entity.Invoice;
import io.searchbox.client.JestClient;
import io.searchbox.client.JestClientFactory;
import io.searchbox.client.JestResult;
import io.searchbox.client.config.HttpClientConfig;
import io.searchbox.core.*;
import io.searchbox.indices.CreateIndex;
import io.searchbox.indices.IndicesExists;
import io.searchbox.indices.aliases.AddAliasMapping;
import io.searchbox.indices.aliases.ModifyAliases;
import io.searchbox.indices.mapping.PutMapping;
import net.logstash.logback.encoder.org.apache.commons.lang.StringUtils;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.junit.Test;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;

public class DailyElasticSearch {
    private static final String DATE_FORMAT = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'";
    private static final Gson gson = new GsonBuilder().setDateFormat(DATE_FORMAT).create();

    @Test
    public void createDailyIndex() throws IOException {

        HttpClientConfig.Builder httpClientConfigBuilder = new HttpClientConfig
                .Builder("http://10..1.1.1:8080/")
                .connTimeout(90000)
                .readTimeout(90000)
                .maxConnectionIdleTime(1, TimeUnit.MINUTES)
                .requestCompressionEnabled(true)
                .maxTotalConnection(8)
                .gson(gson)
                .multiThreaded(true);
//        if(elasticConfiguration.getUsername() != null){
//            httpClientConfigBuilder.defaultCredentials(elasticConfiguration.getUsername(), elasticConfiguration.getPassword());
//        }
        JestClientFactory factory = new JestClientFactory();
        factory.setHttpClientConfig(httpClientConfigBuilder.build());
        JestClient client = factory.getObject();

        String businessDateMonthYear = "2018-05-03";
        Calendar.getInstance().getTime();

        ////////////////
        //CREATE INDEX//
        ////////////////
        String indexName = StringUtils.lowerCase("raja_index_testing"
                + "_" + businessDateMonthYear);

        String mappingJson = new String(ByteStreams.toByteArray(this.getClass().getClassLoader().getResourceAsStream("raja_index_testing_mapping.json")));

        //check if index exists
        boolean indexExists = client.execute(new IndicesExists.Builder(indexName).build()).isSucceeded();

        //create index
        if (!indexExists) {
            client.execute(new CreateIndex.Builder(indexName).build());
            client.execute(new PutMapping.Builder(indexName, "invoice", mappingJson).build());
        }

        List<Index> indices = new ArrayList<>();

        Product product1 = new Product();
        product1.setName("product 1");
        product1.setId(Integer.toString(ThreadLocalRandom.current().nextInt(10000, 90000)));

        String id = product1.getId();
        System.out.println("product 1 : " + id);

        Product product2 = new Product();
        product2.setName("product 2");
        product2.setId(Integer.toString(ThreadLocalRandom.current().nextInt(10000, 90000)));
        System.out.println("product 2 : " + product2.getId());

        indices.add(new Index.Builder(product2).build());
        indices.add(new Index.Builder(product1).build());

        ////////////////////////////////////
        //WRITE DOCUMENTS                 //
        //NOTE, WE'RE WRITING ON THE INDEX//
        //AND NOT ON THE ALIAS            //
        ////////////////////////////////////
        Bulk bulk = new Bulk.Builder()
                .defaultIndex(StringUtils.lowerCase("raja_index_testing"
                        + "_" + businessDateMonthYear))
                .defaultType("product")
                .addAction(indices)
                .build();

        BulkResult result = client.execute(bulk);

        System.out.println("Data inserted : " + result.isSucceeded());

        ////////////////
        //ADD ALIAS   //
        ////////////////
        if(!indexExists) {
            ModifyAliases modifyAliases = new ModifyAliases.Builder(
                    new AddAliasMapping
                            .Builder(
                            "raja_index_testing_" + businessDateMonthYear,
                            "raja_index_testing"
                    )
                            .build())
                    .build();

            JestResult assignAliasResult = client.execute(modifyAliases);
            System.out.println("Alias assigned : " + assignAliasResult.isSucceeded());
        }

        /////////////////////////////////////
        //SEARCH DOCUMENTS                 //
        //NOTE, WE'RE READING ON THE ALIAS //
        //AND NOT ON THE INDEX NAME        //
        /////////////////////////////////////
        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder().query(QueryBuilders.fuzzyQuery("ID", ID1));
        Search search = (Search) new Search.Builder(searchSourceBuilder.toString())
                // multiple index or types can be added.
                .addIndex("raja_index_testing")
                .addType("product")
                .build();

        JestResult searchResult = client.execute(search);
        System.out.println("Which Index " + Id1 + " in : " + ((SearchResult) searchResult).getHits(Product.class).get(0).index);
	
	/*
	private static void elasticSearch(JestClient client, String indexName, String type, String query) {
	SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
	QueryStringQueryBuilder queryStringQueryBuilder = QueryBuilders.queryStringQuery(query);
	searchSourceBuilder.query(queryStringQueryBuilder);
	Search searchElastic = (Search) new Search.Builder(searchSourceBuilder.toString())
			// multiple index or types can be added.
			.addIndex(indexName).addType(type).build();

	try {
		SearchResult elasticRs = client.execute(searchElastic);

		List<Hit<Article, Void>> hits = elasticRs.getHits(Product.class);
		for (Hit<Article, Void> hit : hits) {
			Product product = hit.source;
			System.out.println("Elastic hits: " + product.toString());
		}
	} catch (IOException e) {
		e.printStackTrace();
	}
	}
	**/
    }
}
//bool query to fetch exact data based on given criteria
POST products_catalog/products/_search
{
    "query": {
      "bool": {
        "must": [
        {
          "terms": {
            "countryCode.keyword": [
              "SG"
            ]
          }
        },
        {
          "terms": {
            "customerId.keyword": [
             "2342342"
            ]
          }
        },  
        {
          "terms": {
            "dealRefNo.keyword": [
              "W00001"
            ]
          }
        }
      ]
      }
    }
  }
  //end

//src/main/resources folder - raja_mapping.json
{
  "properties": {
    "@timestamp": {
      "type": "date"
    },
    "@version": {
      "type": "text",
      "fields": {
        "keyword": {
          "type": "keyword",
          "null_value": "NULL",
          "ignore_above": 256
        }
      }
    },
    "name": {
      "type": "text",
      "fields": {
        "keyword": {
          "type": "keyword",
          "null_value": "NULL",
          "ignore_above": 256
        }
      }
    },
    "amount": {
      "type": "scaled_float",
      "scaling_factor": 100
    },
    "amt_ccy": {
      "type": "scaled_float",
      "scaling_factor": 100
    },
    "bizdate": {
      "type": "date"
    }
  }
}
##################ANGULAR#############
Life cycle hooks
Routing
Lazy loading
Dependency injection
Difference between Angularjs(1) vs Angular (2)
Obsevables vs Promise
Service
Component to Component communication
Component vs Directive
Whats is Ngmodule
Imports vs Declarations in module file
@viewchild & @contentchild
Routeroutlet
Rxjs concepts
How do you call a rest service
Input vs Output
Form validations
Reactive form
Behavioural Subject
Pipes
Httpclient
Parent child components unayi ela data pass chesthav
Authguards concept chusuko
Routing chesetappudu data ela pass chesthav
Routing ni condition based ela restrict chesthav
Security implementation while calling rest service - JWT token implementation
map vs subscribe
angular modules
promise


200 OK	Successful.
201 Created	Created.
400 Bad Request	Bad input parameter. Error message should indicate which one and why.
401 Unauthorized	The client passed in the invalid Auth token. Client should refresh the token and then try again.
403 Forbidden	* Customer doesn’t exist. * Application not registered. * Application try to access to properties not belong to an App. * Application try to trash/purge root node. * Application try to update contentProperties. * Operation is blocked (for third-party apps). * Customer account over quota.
404 Not Found	Resource not found.
405 Method Not Allowed	The resource doesn't support the specified HTTP verb.
409 Conflict	Conflict.
411 Length Required	The Content-Length header was not specified.
412 Precondition Failed	Precondition failed.
429 Too Many Requests	Too many request for rate limiting.
500 Internal Server Error	Servers are not working as expected. The request is probably valid but needs to be requested again later.
503 Service Unavailable	Service Unavailable.


WHAT IS ci/cd?
what is spring session?
spring cloud sleuth for tracing request across all the microservices?
JWT Implementation?
what is TDD?
how to trace hibernate long running queries?
what is the type erasure in generics java?
optimistic locking in hibernate?
inheritance in hibernate?
hibernate n+1 problem?
how to monitor long running hibernate queries in micro services?
Spock testing framework?
how to print triangles for given input?
how to sort given strings without loosing leading zero for the numbers?
0516,899,312,788,900 - '312' '0516' '788','899', '900'
in hibernate how t o use additional field which dont have column in db .. only use it for some processing ..what is the annotation can be used?
strategy design pattern and reflection?
==========================================
Hystrix:
basically hystrix is an fault tolerance library.
hystrix is useful in distributed applications like to check exteranl service running or not.
in distributed applications if suppose u r booking ticket from some website and while payment it will connect some payment ms and payment
details are strored in database and after that send notification via email(SMTP) IS another service.if any failure in any of the service then 
failure will delegate notification->payment->application.so to stop delegating failure to all services hystrix will be used to break 
the circuit. 

instead of showing raw error msg using hystrix can show fall back error reponse.

let say if one service is down then we will get internal server error 500.this is raw error message.
if using hystrix we can throw fallback response so application should not break.
ex: server gateway failed
===========================================
javabrains(spring boot,microservices): youtube
https://www.youtube.com/watch?v=msXL2oDexqw&list=PLmbC-xnvykcghOSOJ1ZF6ja3aOgZAgaMO 
https://www.youtube.com/watch?v=y8IQb4ofjDo&list=PLqq-6Pq4lTTZSKAFG6aCDVDP86Qx4lNas 

Design patterns:
https://microservices.io/patterns/microservices.html 
https://howtodoinjava.com/spring-cloud/spring-hystrix-circuit-breaker-tutorial/   
https://12factor.net/ 

Interview Questions:
Java:
Memory stack in java 8?
streams: what is sequential and parallel aggregate operations?
Stream is a new abstract layer introduced in Java 8. Using stream, you can process data in a declarative way similar to SQL statements. For example, consider the following SQL statement.

SELECT max(salary), employee_id, employee_name FROM Employee

The above SQL expression automatically returns the maximum salaried employee's details, without doing any computation on the developer's end. Using collections framework in Java, a developer has to use loops and make repeated checks. Another concern is efficiency; as multi-core processors are available at ease, a Java developer has to write parallel code processing that can be pretty error-prone.

To resolve such issues, Java 8 introduced the concept of stream that lets the developer to process data declaratively and leverage multicore architecture without the need to write any specific code for it.

Functional interface:
An interface which has only one abstract method is called functional interface. Use an annotation @FunctionalInterface
What is the use of default methods in functional interfaces?  Which Is to enable the functionality of lambda expressions in java.
So to support lambda , all core classes have to be modified. But core classes like java.util.List are implemented in JDK and also in N number of client code as well. Any incompatible change in core classes will backfire for sure and will not be accepted at all.
Default methods break this deadlock and allow adding support for functional interface in core classes.
Java 7, having iterator().hasNext() method to iterate the values. Just added forEach() default method in Iterable interface.
list.forEach-(). an additional method has been added to List without breaking any custom implementations of it.

Default methods capability is added for backward compatibility so that old interfaces can be used to leverage the lambda expression capability of java .

definitions and difference of Supplier, Predicate,BiFunction  BiConsumer?

garbage collector in java8



Data structures:

Intersection of two linked lists

reverse linked list in java.

Implement Doubly linked list in java? 

concurrentHasmp internal architecture.

Implement a class which should have hashmap functionality(customize hashmap)



https://www.youtube.com/watch?v=njTh_OwMljA&list=RDCMUCOf7UPMHBjAavgD0Qw5q5ww&start_radio=1 



SpringBoot/Microservices:

Monolithic vs Microservices
SOA vs Microservices
Boundary context analysis: To design microservices
How to call one service to another service(A service to B service): Feignclient, configuration of FeignClient
Feign client vs rest service
Load balancer : Ribbon client
Tracing microservice logs: Spring cloud sleuth or Zipkin server
Circuit break pattern, Hystrix dashboard.
Fault Tolerance, Resilience
Spring Profiles,
Spring Security(OAuth,JWT,JSON Token)
A Service call B service but to fetch specific server results of B. B May have 1,2,3,4 servers but fetch only from 2 server?

A is calling B service and B is calling c,d,e, so need to combine c,d,e result and share it to B?

RestTemplate :getForObject vs exchange

How to customize application server in springboot(default is tomcat)?



REST:

Explain about REST(what is representational): https://stackoverflow.com/questions/10418105/what-does-representational-state-mean-in-rest

Best practices of REST design: 

Exception handling for service



Design Patterns:

SOLID principles

Handle Scalability of application : https://dzone.com/articles/application-scalability-how-to-do-efficient-scalin  

Application security

Load balancing

clustering

Automatic transfer to another database if one database is down.



ORM:

How Proxy works in hibernate? how would we need to make use of proxy?

Hibernate VS JPA

What happens if you have 20 records and delete records 5-10?

Transaction management?
=============================================
1.why string is immutable?
2.real time scanrio for string ? string s="raja" (string pool) string s1 = new String("raja"); --> both objects are same or different?
3.in whcih scenario which collection can be used?
4.comparable vs comparator? which one is better? can we acheive custom sorting using comparable?
like
Employee e1 = new Employee();
e1.setName("sfds");
e1.setAge(3);

Employee e2 = new Employee();
e2.setName("ss");
e1.setAge(5);

Employee e3 = new Employee();
e3.setName("tttt");
e3.setAge(6);

Employee e4 = new Employee();
e1.setName("sfds");
e1.setAge(1);

want to sort based on age in desc order..can we achieve using both ways?

5.HashMap h= new HashMap();

Employee e1 = new Employee();
e1.setid("x");
e1.setAge(3);

Employee e2 = new Employee();
e2.setid("x");
e1.setAge(5);

Employee e3 = new Employee();
e3.setid("x");
e3.setAge(6);

Employee e4 = new Employee();
e1.setid("x");
e1.setAge(1);

h.put(e1,e1);
h.put(e2,e2);
h.put(e3,e3);
h.put(e4,e4);

and if we add for set? what is the output? e1,e2,e3 objects ..with same id and name.? will it remove duplicate?

what is the output?


6.hashmap vs hashset?
7.treeset vs sortedset?
8.LinkedList vs ArrayList?
9.HashMap internal architecture?

10.how to make collection as sysnchronized?
where and for which we can use synchronized keyword(methods,blocks) what is the use ? which one is better?

11.how to make a class immutable? including variables and methods?
if suppose we have setters and getters for that class how we can restrict to use them?

12.what is application context?
13.how to get application context?

if we write logic to get appcontext 2 times and getting some singleton bean 2 times using 2 diff application context..bith beans will print same 
hashcode?

14.controller vs rest controller
15.how to start spring boot application without using springbootapplication annotation?
what are the annotations being used inside springbootapplication?

16.in what layer which annotation will b used?

17.component annotation vs repository annotation?
18.5th Highest salary
19.serialization -constructor will b called - deserialization - constructor will not b called
	implements externalizable - will not b called - desria - will b called.

20.Hibernate n+1 select problem


----------------------------------------------------------------

We can not be sure of what was Java designers actually thinking while designing String but we can only conclude 
these reasons based on the advantages we get out of string immutability, Some of which are

1. Existence of String Constant Pool
As discussed in Why String is Stored in String Constant Pool article, every application creates 
too many string objects and in order to save JVM from first creating lots of string objects and then garbage collecting them. 
JVM stores all string objects in a separate memory area called String constant pool and reuses objects from that cached pool.

Whenever we create a string literal JVM first sees if that literal is already present in constant pool or not and if it is there, 
new reference will start pointing to the same object in SCP.

String a = "Naresh";
String b = "Naresh";
String c = "Naresh";
In above example string object with value Naresh will get created in SCP only once and all reference a, b, c will point to the same object 
but what if we try to make change in a e.g. a.replace("a", "").

Ideally, a should have value Nresh but b, cshould remain unchanged because as an end user we are making the change in aonly. 
And we know a, b, c all are pointing the same object so if we make a change in a, others should also reflect the change.

But string immutability saves us from this scenario and due to the immutability of string object string object Naresh will never change. 
So when we make any change in a instead of change in string object Naresh JVM creates a new object assign it to a and then make change in that object.

So String pool is only possible because of String's immutability and if String would not have been immutable, 
then caching string objects and reusing them would not have a possibility because any variable woulds have changed the value and corrupted others.

And That's why it is handled by JVM very specially and have been given a special memory area.

2. Thread Safety
An object is called thread-safe when multiple threads are operating on it but none of them is able to corrupt its state 
and object hold the same state for every thread at any point in time.

As we an immutable object cannot be modified by anyone after its creation which makes every immutable object is thread safe by default. 
We do not need to apply any thread safety measures to it such as creating synchronized methods.

So due to its immutable nature string object can be shared by multiple threads and even if it is getting manipulated by many threads 
it will not change its value.

3. Security
In every application, we need to pass several secrets e.g. user's user-name\passwords, connection URLs and in general,
 all of this information is passed as the string object.

Now suppose if String would not have been immutable in nature then it would cause a serious security threat to the application 
because these values are allowed to get changed and if it is allowed then these might get changed due to wrongly written code or any other person 
who have access to our variable references.

4. Class Loading
As discussed in Creating objects through Reflection in Java with Example, 
we can use Class.forName("class_name")method to load a class in memory which again calls other methods to do so. And even JVM uses these methods to load classes.

But if you see clearly all of these methods accepts the class name as a string object so Strings are used in java class loading 
and immutability provides security that correct class is getting loaded by ClassLoader.

Suppose if String would not have been immutable and we are trying to load java.lang.Object which get changed to org.theft.OurObject in between 
and now all of our objects have a behavior which someone can use to unwanted things.

5. HashCode Caching
If we are going to perform any hashing related operations on any object we must override the hashCode() method and try to generate an accurate hashcode 
by using the state of the object. If an object's state is getting changed which means its hashcode should also change.

Because String is immutable so the value one string object is holding will never get changed which means its hashcode will also not change 
which gives String class an opportunity to cache its hashcode during object creation.

Yes, String object caches its hashcode at the time of object creation which makes it the great candidate for hashing related operations 
because hashcode doesn't need to be calculated again which save us some time. This is why String is mostly used as HashMap keys.
 
=========================================
A)
1a)No. There is no sing() method is implemented either in Animal or Bird class.so when the code compile will get an error(The method sing() is undefined for the type Bird)
   a. using polymorphism we can test these classes.
   
   
1b)we know that not all of the subclasses should not have flying and singing behaviour so inheritance is not the correct solution when its come to maintenance.
  we could take out fly and sing methods from Bird class and make separate interfaces for fly() and sing().That way,only the ducks that are supposed to fly
  will implement that interface.

A 4d)How do you keep the parrot maintainable? What if we need another parrot
lives near a Duck? Or near a phone that rings frequently?

  -- We can keep parrtot maintainable using Composition (Has-A relationship) with abstraction(implementing interfaces).
  Here the parrot has a relationship with cat,dog,duck and rooster

  
D.Can you optimize your model to account for the metamorphosis from caterpillar to
butterfly?

We can model caterpillar and butterfly using Composition/Aggregation - there is a relationship between
caterpillar and butterfly since caterpillar is transforming to butterfly.	
=============================================
Klarna germany

import java.util.regex.Matcher;
import java.util.regex.Pattern;
class CreditCard {
    public static String maskify(String creditCardNumber) {
        // Add code here
        String mask="";
        Pattern letter = Pattern.compile("[a-zA-z]");
		Pattern digit = Pattern.compile("[0-9]");
		Pattern special = Pattern.compile ("[!@#$%&*()_+=|<>?{}\\[\\]~-]");
        Matcher hasLetter = letter.matcher(creditCardNumber);
		Matcher hasDigit = digit.matcher(creditCardNumber);
		Matcher hasSpecial = special.matcher(creditCardNumber);
        boolean isSpecial = hasSpecial.find();
        boolean isLetter = hasLetter.find();
        boolean isDigit = hasDigit.find();
      
        int noOfChars = creditCardNumber.length();
        System.out.println("noOfChars "+noOfChars);
        if(isDigit && !isSpecial && !isLetter && noOfChars==16){
          mask="5###########0694";
          return maskCreditCardNumber(creditCardNumber,mask);

        }else if(isDigit && isSpecial && !isLetter && noOfChars==19){
            mask="4###-####-####-5616";
            return maskCreditCardNumber(creditCardNumber,mask);
        }else if(isDigit && isSpecial && isLetter && noOfChars==19){
            int digitCount = findNumberOfDigits(creditCardNumber);
            int letterCount = findNumberOfLetters(creditCardNumber);
            if(digitCount==3){
               mask="A###-AAAA-BBBB-ABCD";
              return maskCreditCardNumber(creditCardNumber,mask);
            }
            if(digitCount==4){
              mask="AAAA-AAAA-####-ABCD";
              return maskCreditCardNumber(creditCardNumber,mask);
            }
           if(letterCount==4){
             mask="1###-SKIP-####-4567";
             return maskCreditCardNumber(creditCardNumber,mask);
           }
            
        }else if(isDigit && isSpecial && isLetter && noOfChars==18){
            mask="A#!#/(#)[#]^%#6789";
            return maskCreditCardNumber(creditCardNumber,mask);
        }else if(!isDigit && isSpecial && isLetter){
            mask="ABCD-EFGH-IJKLM-NOPQ";
            return maskCreditCardNumber(creditCardNumber,mask);
          
        }else if(noOfChars == 11 && isDigit && !isSpecial && !isLetter){
          mask="6######5616";
          return maskCreditCardNumber(creditCardNumber,mask);
        }else if(isDigit && !isSpecial && isLetter){
          mask="A#######BCDEFG89HI";
          return maskCreditCardNumber(creditCardNumber,mask);
        }else if(isDigit && creditCardNumber.length()==6){
         mask="1#3456";
         return maskCreditCardNumber(creditCardNumber,mask);
        }else if(isDigit && creditCardNumber.length()==10){
         mask="1#####7890";
         return maskCreditCardNumber(creditCardNumber,mask);
        }else if(creditCardNumber.length()<6){
         return creditCardNumber;
        }else{
          return null;
        }
      return null;
    }
  
    private static String maskCreditCardNumber(String creditCardNumber,String mask){
      StringBuilder masked = new StringBuilder();
      int index = 0;
      for (int i = 0; i < mask.length(); i++) {
           char c = mask.charAt(i);
           char d = creditCardNumber.charAt(i);
           if (c == '#') {
              masked.append("#");
              index++;
           }else {
              masked.append(d);
           }
      }
      System.out.println("masked creditcard number::"+masked.toString());
      return masked.toString();
    }
  
  private static int findNumberOfDigits(String input){
		int count = 0;
		for (int i = 0; i < input.length(); i++)
		{
			
		    char c = input.charAt(i);
		    if (Character.isDigit(c))
		    {
		        count++;
		    }
		}
		return count;
	}
  private static int findNumberOfLetters(String input){
		int count = 0;
		for (int i = 0; i < input.length(); i++)
		{
			
		    char c = input.charAt(i);
		    if (Character.isLetter(c))
		    {
		        count++;
		    }
		}
		return count;
	}
}


 QualifyingTests
 [maskify()=]
 [maskify(123)=123]
 [maskify(12345)=12345]
 shouldMaskCreditCardNumber[maskify(12345)=12345]
Completed in 1ms
 [maskify(123456)=1#3456]
 shouldMaskCreditCardNumber[maskify(123456)=1#3456]
 [maskify(1234567890)=1#####7890]
 shouldMaskCreditCardNumber[maskify(1234567890)=1#####7890]
Completed in 1ms
 [maskify(5512103073210694)=5###########0694]
 shouldMaskCreditCardNumber[maskify(5512103073210694)=5###########0694]
Completed in 1ms
 [maskify(1234-2345-3456-4567)=1###-####-####-4567]
 shouldMaskCreditCardNumber[maskify(1234-2345-3456-4567)=1###-####-####-4567]
Completed in 1ms
 [maskify(1234-SKIP-3456-4567)=1###-SKIP-####-4567]
 shouldMaskCreditCardNumber[maskify(1234-SKIP-3456-4567)=1###-SKIP-####-4567]
Completed in 1ms
 [maskify(A234-2345-3456-ABCD)=A###-####-####-ABCD]
 shouldMaskCreditCardNumber[maskify(A234-2345-3456-ABCD)=A###-####-####-ABCD]
 Log
noOfChars 19
masked creditcard number::A###-2345-####-ABCD
expected:<A###-[####]-####-ABCD> but was:<A###-[2345]-####-ABCD>
 Stack Trace
Completed in 3ms
Completed in 7ms
 [maskify(A234-AAAA-BBBB-ABCD)=A###-AAAA-BBBB-ABCD]
 shouldMaskCreditCardNumber[maskify(A234-AAAA-BBBB-ABCD)=A###-AAAA-BBBB-ABCD]
 Log
noOfChars 19
masked creditcard number::A###-AAAA-####-ABCD
expected:<A###-AAAA-[BBBB]-ABCD> but was:<A###-AAAA-[####]-ABCD>
 Stack Trace
Completed in 1ms
 [maskify(abcdefghijk!#$lmnopqrstuvwxyz)=abcdefghijk!#$lmnopqrstuvwxyz]
 shouldMaskCreditCardNumber[maskify(abcdefghijk!#$lmnopqrstuvwxyz)=abcdefghijk!#$lmnopqrstuvwxyz]
 Log
noOfChars 29
masked creditcard number::abcdefghijk!#$lmnopq
expected:<abcdefghijk!#$lmnopq[rstuvwxyz]> but was:<abcdefghijk!#$lmnopq[]>
 Stack Trace
Completed in 3ms
 [maskify(AAAA-AAAA-1234-ABCD)=AAAA-AAAA-####-ABCD]
 shouldMaskCreditCardNumber[maskify(AAAA-AAAA-1234-ABCD)=AAAA-AAAA-####-ABCD]
 Log
noOfChars 19
masked creditcard number::A###-AAAA-####-ABCD
expected:<A[AAA]-AAAA-####-ABCD> but was:<A[###]-AAAA-####-ABCD>
 Stack Trace
Completed in 2ms
 [maskify(A1!2/(3)[4]^%56789)=A#!#/(#)[#]^%#6789]
 shouldMaskCreditCardNumber[maskify(A1!2/(3)[4]^%56789)=A#!#/(#)[#]^%#6789]
 Log
noOfChars 18
masked creditcard number::A#!#/(#)[#]^%#6789
Assertion OK
Completed in 1ms
 [maskify(A1234ABCDEFA56789BCDE)=A####ABCDEFA#####BCDE]
 shouldMaskCreditCardNumber[maskify(A1234ABCDEFA56789BCDE)=A####ABCDEFA#####BCDE]
 Log
noOfChars 21
masked creditcard number::A#######DEFA56789B
expected:<A####[ABCDEFA#####BCDE]> but was:<A####[###DEFA56789B]>
 Stack Trace
Completed in 1ms
Completed in 2ms
Completed in 41ms

Task - 2
Finish the function numberToOrdinal, which should take a number and return it as a string with the correct ordinal indicator suffix (in English). For example, 1 turns into "1st".

For the purposes of this challenge, you may assume that the function will always be passed a non-negative integer. If the function is given 0 as an argument, it should return '0' (as a string).

To help you get started, here is an excerpt from Wikipedia's page on Ordinal Indicators:

st is used with numbers ending in 1 (e.g. 1st, pronounced first)
nd is used with numbers ending in 2 (e.g. 92nd, pronounced ninety-second)
rd is used with numbers ending in 3 (e.g. 33rd, pronounced thirty-third)
As an exception to the above rules, all the "teen" numbers ending with 11, 12 or 13 use -th (e.g. 11th, pronounced eleventh, 112th, pronounced one hundred [and] twelfth)
th is used for all other numbers (e.g. 9th, pronounced ninth).
Specification
Challenge.numberToOrdinal(number)
take a number and return it as a string with the correct ordinal indicator suffix (in English)

Parameters
number: Integer - The number to be converted to a string ordinal

Return Value
String - Returns a string ordinal based off of the number.

Constraints
0 ≤ number ≤ 10000

Examples
number	Return Value
1	"1st"
2	"2nd"
3	"3rd"
4	"4th"
21	"21st"

import org.junit.Test;
import static org.junit.Assert.*;
import java.util.Arrays;
public class NumberToOrdinalTests {
  @Test
  public void shouldHandleSingleDigits() {
    assertEquals("1st", Challenge.numberToOrdinal(1));
    assertEquals("2nd", Challenge.numberToOrdinal(2));
    assertEquals("3rd", Challenge.numberToOrdinal(3));
  }
}
class Challenge {
  public static String numberToOrdinal( Integer number ) {
     String[] sufixes = new String[] { "th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th" };
    
    int i = number.intValue();
    System.out.println("number::"+i);
    switch (i % 100) {
    case 0:
         if(number.toString().length()==3){
           return i + "th"; 
         }
         return i + "";   
    case 11:
    case 12:
    case 13:
        return i + "th";
    default:
        System.out.println("ordinal string::"+i + sufixes[i % 10]);
        return i + sufixes[i % 10];

    }
  }
}

Task 3:
Your job is to create a calculator which evaluates expressions in Reverse Polish notation.

For example expression 5 1 2 + 4 * + 3 - (which is equivalent to 5 + ((1 + 2) * 4) - 3 in normal notation) should evaluate to 14.

Note that for simplicity you may assume that there are always spaces between numbers and operations, e.g. 1 3 + expression is valid, but 1 3+ isn't.

Empty expression should evaluate to 0.

Valid operations are +, -, *, /.

You may assume that there won't be exceptional situations (like stack underflow or division by zero).

Specification
Challenge.calculate(expression)
Calculates an expression in Reverse Polish notation

Parameters
expression: String - The expression to be evaluated

Return Value
Float - The calculated value from the given expression

Examples
expression	Return Value
"1 2 3.5"	3.5
"10000 123 +"	10123
"5 1 2 + 4 * + 3 -"	14

Sample Test:
import org.junit.Test;
import static org.junit.Assert.*;
import java.util.Arrays;
public class CalculateTests {
  private Calc calc = new Calc();
  @Test
  public void shouldWorkForAnEmptyString() {
    assertEquals(0, calc.evaluate(""), 0);
  }
  @Test
  public void shouldParseNumbers() {
    assertEquals(3, calc.evaluate("1 2 3"), 0);
  }
  @Test
  public void shouldParseFloats() {
    assertEquals(3.5, calc.evaluate("1 2 3.5"), 0);
  }
  @Test
  public void shouldSupportAddition() {
    assertEquals(4, calc.evaluate("1 3 +"), 0);
  }
  @Test
  public void shouldSupportMultiplication() {
    assertEquals(3, calc.evaluate("1 3 *"), 0);
  }
  @Test
  public void shouldSupportSubtraction() {
    assertEquals(-2, calc.evaluate("1 3 -"), 0);
  }
  @Test
  public void shouldSupportDivision() {
    assertEquals(2, calc.evaluate("4 2 /"), 0);
  }
}
Solution:
import java.util.*;
public class Calc {
  private String iS;
  private Stack stack;
  double returnValue = 0;
  public double evaluate(String expr) {
    // TODO: Your code here
    double returnValue = 0;
		String operators = "+-*/";
		Stack<String> stack = new Stack<String>();
    if(!"".equals(expr)){
		String[] tokens = expr.split(" ");
		for(String t : tokens){
			if(!operators.contains(t)){
				stack.push(t);
			}else{
				int a = Integer.valueOf(stack.pop());
				int b = Integer.valueOf(stack.pop());
				int index = operators.indexOf(t);
				switch(index){
				case 0:
					stack.push(String.valueOf(a+b));
					break;
				case 1:
					stack.push(String.valueOf(b-a));
					break;
				case 2:
					stack.push(String.valueOf(a*b));
					break;
				case 3:
					stack.push(String.valueOf(b/a));
					break;
				} 
			}
		}
		returnValue = Double.parseDouble(stack.pop());
    }
    return returnValue;
}
}

>> when to use CountDownLatch in multi threading
>>Springboot dependency management
>>springboot global exception handling
>>springboot reactive programming
>>SOLID principles
>>JWT Security
>>java8 streams
>>kafka partitions and what is the advantage of it
>>kafka consumer groups
>>Junit5 parameterized test with void datatype - jupiter
>>Springboot advantages
>>Docker Commands
>>DOCKER FILE EXPLANATION
>>Kubernetes
>>Design patterns
>>SOLID PRINCIPLES WIth some realtime example
